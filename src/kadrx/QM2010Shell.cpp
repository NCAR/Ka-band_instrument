/// QM2010Terminal.cpp
///
///      Author: Chris Burghart <burghart@ucar.edu>
///
/// Open a connection to a QM2010 oscillator and send it commands typed by
/// the user and display the replies (if any)
///

#include <fcntl.h>
#include <unistd.h>

#include <cerrno>
#include <cstring>
#include <string>
#include <fstream>
#include <iostream>
#include <sstream>

int DevFd = 0;

// We have to wait briefly for replies to be available. This is our wait time
// in microseconds.
static const int REPLY_WAIT_US = 100;

// Read reply from the QM2010
std::string
readReply() {
    char buf[256];
    int nread = read(DevFd, buf, sizeof(buf));
    if (nread == -1) {
        std::cerr << "Error " << errno << " reading from oscillator" <<
                     std::endl;
        exit(1);
    }

    // Strip trailing whitespace character(s) from the reply
    std::string reply(buf, nread);
    reply.erase(reply.find_last_not_of(" \n\r\t") + 1);
    return(reply);
}

// Print any messages in the QM2010's error queue
void
printQM2010Errors() {
    bool hadError(false);

    while (true) {
        std::string cmd("SYS:ERR?");
        write(DevFd, cmd.c_str(), cmd.length());
        usleep(REPLY_WAIT_US);

        std::string reply(readReply());
        if (reply.length() > 0) {
            // We're done if the reply is: 0,"No Error"
            if (reply == std::string("0,\"No Error\"")) {
                break;
            }

            // Ignore error: -400,"Query Error"
            // This error is generated by any command string which does not
            // end with a query, but we allow that in this shell.
            if (reply == std::string("-400,\"Query error\"")) {
                continue;
            }

            // Add a header before the first error
            if (! hadError) {
                hadError = true;
                std::cout << "Error(s) received: " << std::endl;
            }

            // Print the error message
            std::cout << "    " << reply << std::endl;
        } else {
            std::cerr << "No reply received for '" << cmd << "' command" <<
                         std::endl;
        }
    }
}

int
main(int argc, char * argv[]) {
    if (argc != 2) {
        std::cerr << "Usage: " << argv[0] << " <oscillator_device>" <<
                     std::endl;
        std::cerr << std::endl;
        std::cerr << "Note: the device name is generally /dev/usbtmc0" <<
                     std::endl;
        exit(1);
    }

    // Open the selected device
    std::string devName(argv[1]);
    DevFd = open(devName.c_str(), O_RDWR);
    if (DevFd < 0) {
        std::cerr << "Failed to open " << devName << ": " << strerror(errno) <<
                     std::endl;
        exit(1);
    }

    // Print instructions if we're running interactively
    bool interactive = isatty(STDIN_FILENO);
    if (interactive) {
        std::cout << "QM2010 OSCILLATOR SHELL" << std::endl;
        std::cout << "device: " << devName << std::endl;
        std::cout << "-----------------------" << std::endl;
        std::cout << std::endl;
        std::cout << "Enter QM2010 commands at the prompt." << std::endl;
        std::cout << "Enter an empty command to exit." << std::endl;
        std::cout << std::endl;
        std::cout << std::endl;
    }

    // Clear any residual errors queued in the device
    write(DevFd, "*CLS", 4);

    // Loop to read commands from the user, pass them to the oscillator, and
    // print the replies (if any). The loop exits when the user enters an empty
    // command
    while (true) {
        // Prompt
        std::cout << "QM2010 > ";
        std::flush(std::cout);

        // Get the user's next command and strip trailing whitespace
        std::string cmd;
        std::getline(std::cin, cmd);
        cmd.erase(cmd.find_last_not_of(" \n\r\t") + 1);

        // If it's not an interactive shell, echo the command that was read
        if (! interactive) {
            std::cout << cmd << std::endl;
        }

        // Move to the next line if we got a comment
        if (cmd.c_str()[0] == '#') {
            continue;
        }

        // Exit if:
        //   o It's an interactive terminal and the user entered an
        //     empty command
        //   o We hit EOF from a script file
        if ((interactive && cmd.length() == 0) || std::cin.eof()) {
            break;
        }

        // Continue if we got an empty command
        if (cmd.length() == 0) {
            continue;
        }
 
        // Send the command to the oscillator
        write(DevFd, cmd.c_str(), cmd.length());
        usleep(REPLY_WAIT_US);

        // Read and print the reply
        std::string reply(readReply());
        std::cout << ((reply.length() > 0) ? reply : "<no reply>") << std::endl;

        // Print errors that were generated, if any
        printQM2010Errors();
    }

    close(DevFd);
}

