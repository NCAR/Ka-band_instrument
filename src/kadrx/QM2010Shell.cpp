/// QM2010Terminal.cpp
///
///      Author: Chris Burghart <burghart@ucar.edu>
///
/// Open a connection to a QM2010 oscillator and send it commands typed by
/// the user and display the replies (if any)
///

#include <fcntl.h>
#include <unistd.h>

#include <cerrno>
#include <cstring>
#include <string>
#include <fstream>
#include <iostream>
#include <sstream>

int DevFd = 0;

// We have to wait briefly for replies to be available. This is our wait time
// in microseconds.
static const int REPLY_WAIT_US = 100;

// Print any messages in the QM2010's error queue
void
printQM2010Errors() {
    bool hadError(false);

    while (true) {
        std::string cmd("SYS:ERR?");
        write(DevFd, cmd.c_str(), cmd.length());
        usleep(REPLY_WAIT_US);

        char buf[128];
        int nread = read(DevFd, buf, sizeof(buf));
        if (nread > 0) {
            // Strip trailing newline character(s) from the reply
            std::string reply(buf, nread);
            reply.erase(reply.find_last_not_of(" \n\r\t") + 1);

            // We're done if the reply is: 0,"No Error"
            if (reply == std::string("0,\"No Error\"")) {
                break;
            }

            // Ignore error: -400,"Query Error"
            // This error is generated by any command string which does not
            // end with a query, but we allow that in this shell.
            if (reply == std::string("-400,\"Query error\"")) {
                continue;
            }

            // Add a header before the first error
            if (! hadError) {
                hadError = true;
                std::cout << "Error(s) received: " << std::endl;
            }

            // Print the error message
            std::cout << "    " << reply << std::endl;
        } else {
            std::cerr << "No reply received for '" << cmd << "' command" <<
                         std::endl;
        }
    }
}

int
main(int argc, char * argv[]) {
    if (argc != 2) {
        std::cerr << "Usage: " << argv[0] << " <oscillator_device>" << std::endl;
        exit(1);
    }

    // Open the selected device
    std::string devName(argv[1]);
    DevFd = open(devName.c_str(), O_RDWR);
    if (DevFd < 0) {
        std::cerr << "Failed to open " << devName << ": " << strerror(errno) <<
                     std::endl;
        exit(1);
    }

    std::cout << "QM2010 OSCILLATOR SHELL" << std::endl;
    std::cout << "device: " << devName << std::endl;
    std::cout << "-----------------------" << std::endl;
    std::cout << std::endl;
    std::cout << "Enter QM2010 commands at the prompt." << std::endl;
    std::cout << "Enter an empty command to exit." << std::endl;
    std::cout << std::endl;
    std::cout << std::endl;

    // Clear any residual errors queued in the device
    write(DevFd, "*CLS", 4);

    // Loop to read commands from the user, pass them to the oscillator, and
    // print the replies (if any). The loop exits when the user enters an empty
    // command
    while (true) {
        // Prompt
        std::cout << "QM2010# ";
        std::flush(std::cout);

        // Get the user's next command
        std::string cmd;
        std::getline(std::cin, cmd);
        if (cmd.length() <= 0) {
            break;
        }

        // Send the command
        write(DevFd, cmd.c_str(), cmd.length());
        usleep(REPLY_WAIT_US);

        // Read and print the reply
        char reply[128];
        int nread = read(DevFd, reply, sizeof(reply));
        if (nread > 0) {
            std::cout << std::string(reply, nread);
        } else {
            std::cout << "<no reply>" << std::endl;
        }

        // Print errors that were generated, if any
        printQM2010Errors();
    }

    close(DevFd);
//    std::string devName("/dev/usbtmc0");
//    std::ofstream os(devName.c_str());
//    std::ifstream is(devName.c_str());
//    os << "POWER:RF?";
//    usleep(500000);
//    std::string line;
//    is >> line;
//    std::cout << line << std::endl;
//    os.close();
//    is.close();
}




